<!DOCTYPE html>
<meta charset="utf-8">
<title>aps-citiations_cleaned.mtx_23_IMPR_circle.json</title>
<style>
.node {
  cursor: pointer;
  stroke: #000;
  stroke-width: 0.1px;  
}
.node:hover {
  stroke: #000 !important;
  stroke-width: 8px !important;
}
.node--leaf {
  fill: white;
}
.label {
  font: 16px "Helvetica Neue", Helvetica, Arial, sans-serif;
  text-anchor: middle;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
}
.label,
.node--root {
  pointer-events: none;
}
.brush .extent {
  fill-opacity: .1;
  stroke: #fff;
  shape-rendering: crispEdges;
}
* {
    box-sizing: border-box;
}
.row::after {
    content: "";
    clear: both;
    display: table;
}
[class*="col-"] {
    float: left;
    padding: 15px;
}
.col-1 {width: 8.33%;}
.col-2 {width: 16.66%;}
.col-3 {width: 25%;}
.col-4 {width: 33.33%;}
.col-5 {width: 41.66%;}
.col-6 {width: 50%;}
.col-7 {width: 58.33%;}
.col-8 {width: 66.66%;}
.col-9 {width: 75%;}
.col-10 {width: 83.33%;}
.col-11 {width: 91.66%;}
.col-12 {width: 100%;}
#get_input{
    width: 100px;
}
</style>
<body>
    <div class="container" style="width: 100%;">
        <div class="row">
            <!--<div class="col-1">
                <input id="brush_toggle" type="button" value="Brush Off" onclick="toggleBrush()" />
            </div>-->
            <div class="col-1">
                <input id="submit_size" type="button" value="Update Visual">
            </div>
            <div class="col-2">
                Size: <input id="size_limiter" type="text" name="size_change" value=""><br> 
            </div>
            <div class="col-1">
                <input type="checkbox" id="author">Author<input type="checkbox" id="paper">Paper<input type="checkbox" id="word">Word
            </div>
            <div class="col-1">
                <input id="find_data" type="button" name="Find" value="Search"><br> 
            </div>
            <div class="col-2">
                Input: <input id="get_input" type="text" name="paper_name" value=""><br> 
            </div>
            
        </div>
        <div class="row">
            <div class="col-8">
                <div id="dv_1"></div>  
            </div>
            <div class="col-4">
                <div id="info" style="background-color: white;">
                    <center><b>Paper Information:</b></center><br>
                    <div id="classifcation"></div>
                    <div id="paperinfo" style="width: 500px; height:800px;float: left; background-color: white; overflow-y:scroll;"></div>
                </div>
            </div>
        </div>
    </div>  
</body>

<script src="d3.v3.js"></script>
<script src="Parser.js"></script>
<script src="helper.js"></script>
<script src="jquery-3.1.1.js"></script>
<script src="paperinfo.js"></script>

<script>

var $ = function( id ) { return document.getElementById( id ); };
var margin = 20,
    diameter = screen.height - 170;
var color = d3.scale.linear()
    .domain([0, 1, 2, 3, 4])
    //blue scheme
/*    .range(["rgb(0,0,255)", "rgb(0,255,255)", "rgb(0,255,0)", "rgb(255,255,0)", "rgb(255,0,0)"])*/
    //red scheme
    .range(["#4eb3d3", "#fdd49e", "#fc8d59", "#d7301f", "#7f0000"])
    .interpolate(d3.interpolate); 
var grayColor = d3.scale.linear()
    .domain([0, 1, 2, 3, 4])
    .range(["#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#969696"])
    .interpolate(d3.interpolate);
var pack = d3.layout.pack()
    .padding(2)
    .size([diameter - margin, diameter - margin])
    .value(function(d) { return d.size; })
var svg1 = d3.select("#dv_1").append("svg")
    .attr("width", screen.width - 170)
    .attr("height", diameter)
    .append("g")
    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
function filter(data, size){
  if(data.children == undefined) return;
  data.children = data.children.filter(function(a){return a.size>size;});
  for(var i = 0; i < data.children.length; i++){
    filter(data.children[i], size);
  }
}

var position;
var saveScale = null;
var saveTranslation = null;
var brush_on = false;
var brushCounter = 0
function toggleBrush() {
    brushCounter++;
    brush_on = brushCounter%2 == 0? false : true;
    document.getElementById("brush_toggle").value = brushCounter%2 == 0? "Brush Off" : "Brush On";
};

d3.select("#submit_size").on("click", function() {
    var size = parseInt(document.getElementById("size_limiter").value);
    svg1.selectAll("circle")
        .remove();
    svg1.selectAll("text")
        .remove();
    if(brush_on){
        brush_on = false;
        toggleBrush();
    };
    svg1.selectAll("#myBrush")
        .remove();
    redraw(size);
})

function redraw(size){
    d3.json("aps-citations_cleaned.mtx_23_IMPR_circle.json", function(error, root) {
      if (error) throw error;
      filter(root, size);
      var focus = root,
          nodes = pack.nodes(root),
          view;      
      var circle = svg1.selectAll("circle")
          .data(nodes)      
          .enter().append("circle")      
          .attr("class", function(d) { return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root"; })
          .attr("id",function(d) {
              id = d.index;
              id = "p".concat(String(id));
              return id;
          })
          .style("fill", function(d) { return color(d.color); })    
          .on("click", function(d) { 
                svg1.select("#p".concat(String(d.index)))
                    .style("fill", function(d) { 
                        return color(d.color);
                    });
                console.log(d.index);
                if (d3.event.defaultPrevented != true){
                    $('paperinfo').innerHTML =""; 
                    $("classifcation").innerHTML ="";
                    loadpapers(d.index);

                    if (focus !== d) {
                        zoom(d), d3.event.stopPropagation(),
                        svg1.select("#subgraph_id")
                            .text(parsename(d.name));
                    }else{
                        zoom(root);
                        svg1.select("#subgraph_id")
                            .text(parsename(root.name));
                    }
                }
          })
          .on("mouseover", function(d) {svg1.select("#subgraph_id").text(parsename(d.name))});
        
      d3.select("#find_data").on("click", function() {
        /*svg1.selectAll("circle")
            .style("fill", function(d){
              return grayColor(d.color);
            });*/
        //Just a test to see what the intersections look like
        /*d3.text("IntersectionsComma.csv", function(error2,intersections){
            if (error2) throw error2;
            var dataInt = d3.csv.parseRows(intersections);
            for (var i = 0; i<dataInt.length; i++){
                for (var j = 1; j<dataInt[i].length; j++){
                    svg1.select('#p'.concat(dataInt[i][j]))
                        .style("fill", function(d){
                              return color(d.color);
                    });
                }
            }
            
        })*/
        if (document.getElementById("paper").checked){
            var title = document.getElementById("get_input").value;
            target_circle = revfakedb[titlefile[title]];
            for(var i = 0; i<target_circle.length; i++){
                svg1.selectAll('#p'.concat(target_circle[i]))
                    .style("stroke-width",4)
                    .style("stroke","yellow");
/*                    .style("fill", function(d){
                      return color(d.color);
                    });*/
            }
        }else if (document.getElementById("author").checked){
            var author = document.getElementById("get_input").value;
            for(var j = 0; j<authorfile[author].length; j++){
                if(revfakedb[authorfile[author][j]] != undefined){
                    target_circle = revfakedb[authorfile[author][j]];
                    for(var k = 0; k<target_circle.length; k++){
                        svg1.selectAll('#p'.concat(target_circle[k]))
                            .style("stroke-width",4)
                            .style("stroke","yellow");
                            /*.style("fill", function(d){
                              return color(d.color);
                            });*/
                    }
                }
            }
        }
      })
      
      var zoom2 = d3.behavior.zoom()
            .scaleExtent([1, 100])
            .on("zoom", zoomed);
      svg1.call(zoom2);  
      svg1.append("text")
        .style("font-size", "30px")
        .style("fill", "white")
        .attr("class", "mytext")
        .attr("x", -80)
        .attr("y", -300)
        .attr("id","subgraph_id")
        .text(parsename(root.name));

      d3.select("#brush_toggle").on("click", function() {
          console.log("in button");
          if(brush_on){ 
                if (saveScale === null) saveScale = zoom2.scale();
                if (saveTranslation === null) saveTranslation = zoom2.translate();
                  var brush = svg1.append("g")
                  .datum(function() { return {selected: false, previouslySelected: false}; })
                  .attr("class", "brush")
                  .attr("id", "myBrush")
                  .call(d3.svg.brush()
                    .x(d3.scale.identity().domain([-diameter, diameter]))
                    .y(d3.scale.identity().domain([-diameter, diameter]))
                    .on("brushstart", function(d) {
                      node.each(function(d) { d.previouslySelected = d.selected; });
                    })
                    .on("brush", function() {
                      var extent = d3.event.target.extent();
                      node.classed("selected", function(d) {
                        return d.selected = d.previouslySelected ^
                            (extent[0][0] <= d.x && d.x < extent[1][0]
                            && extent[0][1] <= d.y && d.y < extent[1][1]);
                      });
                    })
                    .on("brushend", function() {
                      d3.event.target.clear();
                      d3.select(this).call(d3.event.target);
                    }));
          } else {
                if (saveScale !== null) zoom2.scale(saveScale);
                if (saveTranslation !== null) zoom2.translate(saveTranslation);
                console.log("in remove");
                svg1.selectAll("#myBrush")
                .remove();
          };    
      });  

      circle = circle.filter(function(d) {return (d.size >= 0) && (d.name != "")});
    //#      .style("stroke-dasharray", "5,5", "important");
    //#      .style("stroke", "#000", "important")
    //#      .style("stroke-width", 1, "important");
      /*
      var text = svg1.selectAll("text")
          .data(nodes)
        .enter().append("text")
          .attr("class", "label")
          .style("fill-opacity", function(d) { return d.parent === root ? 1 : 0; })
          .style("display", function(d) { return (d.parent === root && d.size >= 0) ? "inline" : "none"; })
          .text( function(d) { return d.name; });
      text = text.filter(function(d) {return (d.size >= 0)});
      */
      var node = svg1.selectAll("circle");
/*      d3.select("#dv_1")
          .style("background", "rgb(255,255,255)")
          .on("click", function() { zoom(root); });*/
      zoomTo([root.x, root.y, root.r * 2 + margin]);
      
      function zoom(d) {
        var focus0 = focus; focus = d;
        circle.filter(function(d) {return (d.fl == "aps-citations_cleaned.mtx_23_IMPR_circle.json" && d.parent === focus && focus !== root); })
    //#    .style("stroke-dasharray", "5,5");
        .style("stroke", "#000")
        .style("stroke-width", 4)
        .style("stroke-dasharray", "4,4");
        circle.filter(function(d) {return (d.fl == "aps-citations_cleaned.mtx_23_IMPR_circle.json" && d === focus && focus !== root); })
    //#    .style("stroke-dasharray", "10,10");
    // #    .style("stroke", "rgb(255,255,255)")
        .style("stroke-width", 4)
        .style("stroke-dasharray", "40,40");
        circle.filter(function(d) {return (d.fl == "aps-citations_cleaned.mtx_23_IMPR_circle.json" && (d.parent !== focus && d !== focus)); })
        .style("stroke", "#000")
        .style("stroke-width", 1.0)
        .style("stroke-dasharray", "none");

        var transition = d3.transition()
            .duration(d3.event.altKey ? 7500 : 750)
            .tween("zoom", function(d) {
              var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
              return function(t) { zoomTo(i(t)); };
            });

        /*
        transition.selectAll("text")
          .filter(function(d) { return (d.size >= 0 && d.fl == "aps-citiations_cleaned.mtx_23_IMPR_circle.json" &&
          (d.parent === focus || (d === focus && d.children == null) || this.style.display === "inline")); })
            .style("fill-opacity", function(d) { return (d.parent === focus || (d === focus && d.children == null))? 1 : 0; })
            .each("start", function(d) { if (d.parent === focus || (d === focus && d.children == null)) this.style.display = "inline"; })
            .each("end", function(d) { if (d.parent !== focus && (d !== focus && d.children == null)) this.style.display = "none"; });
         */
      }

      function zoomTo(v) {
        var k = diameter / v[2]; view = v;
        node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
        circle.attr("r", function(d) { return d.r * k; });
        zoom2.scale(980 / (focus.r*2 + margin)); 
        position = zoom2.translate();
        zoom2.translate([0,0]);
      }

      function zoomTo2(v) {

        var k = diameter / v[2]; view = v;
        node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
        circle.attr("r", function(d) { return d.r * k; });
      } 

      function zoomed() {
        if (brush_on !== true){
            
            var s = zoom2.scale();
            var panVector = zoom2.translate();
            saveScale = s;
            saveTranslation = panVector;

            var panX = panVector[0];
            var panY = panVector[1];
            x = focus.x - (panX - position[0])/s;
            y = focus.y - (panY - position[1])/s;
            r = diameter/s;

            d3.transition()
                .duration(0)
                .tween("zoom", function() {
                    var i = d3.interpolateZoom(view, [x, y, r]);
                    return function(t) { zoomTo2(i(t)); };
                });  
        }
      };
    });
}

d3.select(self.frameElement).style("height", diameter + "px");
</script>